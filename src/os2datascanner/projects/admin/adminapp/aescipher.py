import os
import secrets
import structlog

from django.conf import settings
from django.core.mail import EmailMessage
from django.core.exceptions import ImproperlyConfigured

from ...utils import aes

logger = structlog.get_logger("adminapp")


def encrypt(plaintext, key=None):
    return aes.encrypt(plaintext, key or get_key())


def decrypt(iv, ciphertext, key=None):
    return aes.decrypt(iv, ciphertext, key or get_key())


def get_key():
    key = None
    if settings.DECRYPTION_HEX:
        key = bytes.fromhex(settings.DECRYPTION_HEX)
    else:
        _email_admin(
            "CRITICAL!",
            "The configuration key DECRYPTION_HEX is not set!\n\n" +
            "If the system has previously used a file to store the key for " +
            "decryption, the hex value can be retrieved by calling:\n\n" +
            "\tos2datascanner.projects.admin.adminapp.aescipher." +
            "get_hex_from_key_file(<full key_file path>\n\n" +
            "If not, a new value can be generated by calling:\n\n"
            "\tos2datascanner.projects.admin.adminapp.aescipher." +
            "generate_new_hex()\n\n" +
            "The hex value should be stored in user-settings.toml:\n\n" +
            "DECRYPTION_HEX = \"<hex value>\""
        )
        raise ImproperlyConfigured("The setting DECRYPTION_HEX is empty")
    return key


def generate_new_hex():
    # AES supports multiple key sizes: 16 (AES128), 24 (AES192), or 32 (AES256).
    return (secrets.randbits(8 * 32)
            .to_bytes(32, "big")
            .hex())


def _email_admin(subject, body):
    try:
        message = EmailMessage(subject, body, settings.ADMIN_EMAIL)
        message.send()
    except Exception:
        logger.error(
            'Error occurred while sending email to administrator.'
        )


def get_hex_from_key_file(file_name):
    key = None
    if os.path.isfile(file_name):
        key = key_file_handling(None, 'rb', file_name, False)
    else:

        _email_admin('CRITICAL!', 'New master key has been generated.')

    return key


def key_file_handling(data, command, filename, create):
    file = None
    try:
        if create and not os.path.isfile(filename):
            os.mknod(filename)
        file = open(filename, command)
        if command == 'rb':
            data = file.read()
        elif command == 'ab':
            file.write(data)
    except OSError as ex:
        logger.error('An error occured while trying to {0} {1} file. {2}'.format(
            command,
            filename,
            ex))
    finally:
        if file is not None:
            file.close()
    return data
